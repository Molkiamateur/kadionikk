python1 :

Pour 'A': 

[ 1391.474665] vuln1[14055]: segfault at 41414141 ip 0000000041414141 sp 00000000ffc23e80 error 14 likely on CPU 1 (core 1, socket 0)

Pour 'B':

[ 1541.811759] vuln1[15418]: segfault at 42424242 ip 0000000042424242 sp 00000000ff8b1620 error 14 likely on CPU 3 (core 3, socket 0)

exo 5 : python2 test2

[ 4044.855638] vuln1[36113]: segfault at 0 ip 00000000ffffd3a0 sp 00000000ffffd3a0 error 6 likely on CPU 5 (core 1, socket 0)

=> hexadecimaux en little endian (tah a l'envers)


exo 6 : tout dans le bash

creation du pattern avec -l 300

echo "pattern" |nc ip et port

le message dmesg

pattern offset avec le ip register

exo 7: 

bien penser à mettre des 0x90 entre ip_reg et le payload car 90 est l'opcode du NOP(No-operation), il permet de faire le saut dans les NOP donc executer le Payload du début(ici TCP).

partie 3 :


on cree l'arborescence de msf4, on modifie le ruby en ajoutant la cible (kali avec son reg sp) et 80, on choisit l'exploit qu'on veut puis mettre les variables de la cible(ip, port d'ecoute, et port du shell, payload). On execute exploit.



exo 8 : 

tout est pareil seulement on obtient une segfault car notre code n'a pas les droits de s'executer. ecrit dans le code d'erreur (erreur 15 au lieu de 14).

exo 9 :

on obtient stack smashing detected, cela signifie que l'on s'est fait cramé(il faut courrir très vite)

exo 10: 

en ayant l'aslr, le registre sp et random a chaque appel

on observe que l'ecart est variable, mauvaise estimation de l'ecart donc on depasse la pile 

0x1f21d : ecart moyen sur 100 calculs














